---
title: "Análisis Numérico"
description: "Sitio de la asignatura análisis numérico en la UniAutonoma del Cauca"
subtitle: "Ingeniería de software y computación"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: "2023-08-01"
format:
  revealjs: 
    code-tools: true
    code-overflow: scroll
    code-line-numbers: true
    code-copy: false
    fig-align: center
    self-contained: true
    theme: 
      - white
      - custom.scss
    slide-number: true
    preview-links: auto
    logo: images/medes.png
    css: styles.css
    footer: <https://pacaicedo.github.io>
    transition: fade
resources:
  - demo.pdf
---

# Análisis Numérico

## El Profesor {.smaller}

::: columns

:::: column


### Educación

Doctor en Ciencias de la Electrónica.
Magíster en Ingeniería Electrónica y Telecomunicaciones
Ingeniero en Electrónica y Telecomunicaciones

### Intereses

Biomecánica, Dispositivos para el análisis de movimiento humano, ciencia de los datos.

::::

:::: column

### Desempeño

Profesor de la Facultad de Ingeniería

Invest. Línea de Percep. Avanz. y Robótica -- GITA

Director Grupo de Investigación MEDES.

Director del laboratorio de datos de la Uniautonoma.

::::

:::

### Contacto:

pablo.caicedo.r@uniautonoma.edu.co


## Contenido del curso

:::columns

:::: column

![](./images/NumericalAnalysis/numerical_analysis_01.jpeg){ height="600" }

::::

:::: column

1. Introducción al análisis numérico
2. Solución de ecuaciones
3. Interpolación y aproximaciones lineales
4. Diferenciación e integración numérica
5. Problemas de valor inicial para solución de ecuaciones diferenciales ordinarias

::::

:::

## Evaluación

:::columns

:::: column

\scriptsize

1. Comprensión de lectura (Inglés) (10%)
2. Consigna 001. Solución de ecuaciones - Interpolación y aproximaciones lineales (25%)
2. Consigna 002. Diferenciación e integración numérica (25%)
3. Consigna 003. Proyecto Final (40%)

\normalsize

::::

:::: column

![](images/evaluacion.jpg)

::::

:::


## Recursos

### Clases

Lunes, Martes, Miércoles y Jueves
9:00 -- 11:00
Sala 504

[Sala de teams](https://teams.microsoft.com/l/channel/19%3aXtToBJm4BKK4XyFP47UVcSYBhCR1JosQE-qQ6Kk6TKE1%40thread.tacv2/General?groupId=928c3615-fd66-4e37-92de-5b85feb03424&tenantId=c91fc68b-7571-4551-933c-467a6c58bf58)


### Software
**Interpretes:** Python, R, Latex(TEXLive), Anaconda.

**IDE:** Visual Studio Code, Google Colaboratory ([R](https://colab.to/r), [Python](https://colab.to))

**Librerías** Numpy.

**Seguimiento de Aprendizaje:** Moodle


## Bibliografía{.scrollable}


1. Angarita, A. (2013). Apuntes De Análisis Numérico. Departamento de Ciencias Básicas - Unidades Tecnológicas de Santander.
2. Burden, R. L., Faires, J. D., & Burden, A. M. (2016). Análisis Numérico (Tenth edition). Cengage Learning.
3. Chapra, S. C., Canale, R. P., & Del Valle Sotelo, J. C. (2008). Métodos numéricos para ingenieros (5a ed). McGraw-Hill.
4. Arévalo Ovalle, D., Bernal Yermanos, M. Á., & Posada Restrepo, J. A. (2021). Métodos numéricos con Python. Editorial Politécnico Grancolombiano.
5. Corriou, J.-P. (2021). Numerical Methods and Optimization: Theory and Practice for Engineers (Vol. 187). Springer International Publishing. https://doi.org/10.1007/978-3-030-89366-8
6. Gilat, A., & Subramaniam, V. (2014). Numerical methods for engineers and scientists: An introduction with applications using matlab (Third edition). John Wiley & Sons, Inc.
7. Miles, W. (2023). Numerical Methods with Python: For the sciences (1st ed.). De Gruyter.



# Introducción al análisis numérico

## Errores y aproximaciones

::: columns

:::{.column width="50%"}

Las cantidades que se trabajan en la ingeniería tienen dos orígenes diferentes:

- Mediciones sobre procesos físicos
- Resultados de procesos matemáticos.

:::

:::{.column width="50%"}

::: {.callout-note title="Primer Origen" collapse="false"}

Un proceso de medición nunca arroja el valor verdadero de la medida, pues las mediciones se hacen con instrumentos que se encuentran limitados

:::

::: {.callout-important title="Segundo Origen" collapse="false"}

Las operaciones aritméticas usualmente se ejecutan en un computador o una calculadora, y la limitación de espacio de estos dispositivos lleva a que algunas cifras no se puedan representar correctamente.

:::



:::

:::


## Errores y aproximaciones

::: columns

:::{.column width="50%"}

::: {.callout-important title="Importante" collapsible="false"}

Los errores debido a estos orígenes es de naturaleza acumulativa, por ejemplo si se operan medidas reales con un procesador limitado la incertidumbre aumentará.

:::



:::

:::{.column width="50%"}

::: {.callout-important title="Importante" collapsible="false"}

Muchas veces resulta imposible siquiera expresar en términos algebraicos soluciones a ciertas ecuaciones, inclusive polinomiales.

:::



:::

:::

::: {.callout-tip title="Siempre..." collapsible="false"}

Con lo anterior, es claro que el trabajo de ingeniería y ciencias se encuentra inevitablemente sujeto a error, y por tanto el tema de cuantificación de errores es de atención prioritaria en dichas áreas.

:::

## Errores y aproximaciones

::: columns

:::{.column width="50%"}

### Error Absoluto

$$\varepsilon = \left| x - \bar{x} \right|$$

:::

:::{.column width="50%"}

### Error relativo

$$\varepsilon_{\gamma} = \frac{\left| x - \bar{x} \right|}{\left| x \right|}$$

:::

:::

### Error de aproximación

$$\varepsilon_{ap} = {\left| x_{actual} - x_{anterior} \right|}$$


## Cifras significativas

![](./images/NumericalAnalysis/cifras_significativas.png)


## Cifras significativas

::: {.callout-tip title="Considere..." collapsible="false"}

Una región rectangular que tiene 20.5 cm de largo por 14.3 cm de ancho. Se requiere la medida del área de la región en centímetros cuadrados.

:::

::: columns

:::{.column width="50%"}

![](./images/NumericalAnalysis/cifras_significativas.png)

:::

:::{.column width="50%"}

:::{.small_font}

- Diferentes personas reportarían sin dudar los primeros dos dígitos, a saber el dos y el cero, que en este contexto se llamarán dígitos confiables.

- Se entenderá que esta medida en realidad es una cifra entre 20.5 cm y 20.6 cm con el tercer dígito llamado dígito de incertidumbre.

- La cantidad de dígitos confiables más otro con incertidumbre, son las cifras significativas de una medición.

:::



:::

:::


## Cifras significativas

::: {.callout-note title="¿Que pasa con las operaciones?" collapsible="false"}

Cuando se operen números con cifras significativas, el resultado tendrá tantas cifras significativas como el factor con menos cifras significativas.

:::

::: {.callout-important title="Hablando de errores" collapsible="false"}

Con el número de cifras significativas $\left(n\right)$, se puede calcular la cota del error absoluto:

$$\varepsilon = \left( 0.5\times10^{2-n} \right) \%$$

:::


## Que pasa en los computadores?

![](./images/NumericalAnalysis//cifras_significativas_ieee.png)

$$\left(-1\right)^{s}2^{c-1023}\left(1+f\right)$$

## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}

::: {.callout-note title="Dos numeros \"diferentes\" " collapsible="false"}

1. __0 10000000011 1011100100010000000000000000000000000000000000000000__
2. __0 10000000011 1011100100010000000000000000000000000000000000000001__

:::

El bit más izquierdo en ambos casos es "0", por lo tanto en los dos casos los numéros son positivos.

## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}

::: {.callout-note title="Dos numeros \"diferentes\" " collapsible="false"}

1. __0 10000000011 1011100100010000000000000000000000000000000000000000__
2. __0 10000000011 1011100100010000000000000000000000000000000000000001__

:::

En el ambos casos el exponente es _10000000011_ por lo tanto el valor c se calcula así:

:::{.small_font}

$$ c = 1 \cdot 2^{10} + 0 \cdot 2^{9} + \dots +1 \cdot 2^{1} + 1 \cdot 2^{0} = 1024+2+1=1027$$

:::

## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}

::: {.callout-note title="Dos numeros \"diferentes\" " collapsible="false"}

1. __0 10000000011 1011100100010000000000000000000000000000000000000000__
2. __0 10000000011 1011100100010000000000000000000000000000000000000001__

:::

La mantisa para el primer caso es:

:::{.small_font}


$$1011100100010000000000000000000000000000000000000000$$
$$ f = 1 \cdot 2^{-1} + 1 \cdot 2^{-3} + 1\cdot 2^{-4} +1 \cdot 2^{-5} + 1 \cdot 2^{-8} + 1 \cdot 2^{-12} $$
$$ f = 0.5 + 0.125 + 0.0625 + 0.03125 + 0.00390625 + 0.000244140625$$
$$ f= 0.7229003906250000000000$$

:::

## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}

::: {.callout-note title="Dos numeros \"diferentes\" " collapsible="false"}

1. __0 10000000011 1011100100010000000000000000000000000000000000000000__
2. __0 10000000011 1011100100010000000000000000000000000000000000000001__

:::

La mantisa para el segundo caso es:

:::{.small_font}


$$1011100100010000000000000000000000000000000000000001$$
$$ f = 1 \cdot 2^{-1} + 1 \cdot 2^{-3} + 1\cdot 2^{-4} +1 \cdot 2^{-5} + 1 \cdot 2^{-8} + 1 \cdot 2^{-12} + 1 \cdot 2^{-52}$$
$$ f = 0.5 + 0.125 + 0.0625 + 0.03125 + 0.00390625 + 0.000244140625 + 2,220476049250313e-16$$
$$f = 0.7229003906250002220446$$

:::

## Los números \"más grande\" y \"más pequeño\"

::: {.callout-important title="Importante" collapsible="false"}

- **Más grande:** Sucede cuando $s=0$, $c=2046$, $f=1-2^{-52}$
- **Más pequeño:** Sucede cuando $s=0$, $c=1$, $f=0$

:::

## Error de truncamiento

::: columns

:::{.column width="50%"}

::: {.callout-important title="Importante" collapsible="false"}

Dentro de los números reales $\left( \mathbb{R} \right)$, existen dos conjuntos de números claramente diferenciables, los racionales $\left( \mathbb{Q} \right)$ y los irracionales $\left( \mathbb{I} \right)$. Los primeros son facilmente representables en un sistema computacional; sin embargo los segundo debido a que no pueden ser representados con un número finito de digitos deben ser cortados a unas cuantas cifras.

:::



:::

:::{.column width="50%"}

::: {.callout-note title="Nota" collapsible="false"}

Sin embargo, hay formas metódicas de obtener aproximaciones tan buenas como se quieran a estos números. Como por ejemplo las conocidas series de Taylor 

:::{.x_small_font}
$$f\left( x \right) = f\left( c \right) + \dot{f}\left( c \right)\left( x-c \right) + \frac{\ddot{f}\left( c \right)}{2!}\left( x-c \right)^2 + \frac{\dddot{f}\left( c \right)}{3!}\left( x-c \right)^3 + \dots + \frac{f^{\left(n\right)}\left( c \right)}{n!}\left( x-c \right)^n$$
:::

- Todas las derivadas deben existir.
- Función y derivadas  en el intervalo $\left(x,c\right)$

:::

:::

:::

## Error de truncamiento  

::: {.callout-note title="Forma de Langrange" collapsible="false"}

$$R_n\left( x \right) = \frac{f^{\left( n+1 \right)}\left( \xi \right)}{\left( n+1 \right)!}\left( x-c \right)^{n+1}$$

:::

::: {.callout-note title="Forma Integral" collapsible="false"}

$$R_n\left( x \right) = \int_{c}^{x}{\frac{f^{\left(n+1\right)}\left(t\right)}{n!}\left(x-t\right)^{n}dt}$$

:::


## Ejemplo de Error de truncamiento


::: {.callout-warning title="Recordemos" collapsible="false"}

:::{.small_font}

$$f\left( x \right) = f\left( c \right) + \dot{f}\left( c \right)\left( x-c \right) + \frac{\ddot{f}\left( c \right)}{2!}\left( x-c \right)^2 + \frac{\dddot{f}\left( c \right)}{3!}\left( x-c \right)^3 + \dots + \frac{f^{\left(n\right)}\left( c \right)}{n!}\left( x-c \right)^n$$
  

:::



:::



::: {.callout-note title="Calcular ln(1.1), centrado en  c=1, y orden 4" collapsible="false"}

::: columns

:::{.column width="50%"}

$$f\left(x\right)=ln\left(x\right)$$

$$\dot{f}\left(x\right) = \frac{1}{x}$$

$$\ddot{f}\left(x\right) = -\frac{1}{x^2}$$

:::

:::{.column width="50%"}


$$\dddot{f}\left(x\right) = \frac{2}{x^3}$$

$$\ddddot{f}\left(x\right) = -\frac{6}{x^4}$$

:::

:::



:::


## Ejemplo de Error de truncamiento

::: {.callout-note title="Calcular ln(1.1), centrado en  c=1, y orden 4" collapsible="false"}

:::{.small_font}

  $$f\left(1.1\right)=ln\left(1\right)+\frac{1}{1.1}\left(1.1 - 1\right)-\frac{1}{2\cdot 1.1^2}\left(1.1-1\right)^2+\frac{2}{6\cdot 1.1^3}\left(1.1 - 1\right)^3 - \frac{6}{24\cdot 1.1^4}\left(1.1 - 1\right)^4$$

:::



:::

:::{.small_font}

```{python}
#| echo: true
#| eval: true
#| output: true

def taylor_expansion_ln(x):
    return ((1/x)*(x-1))-((1/(2*(x**2)))*(x-1)**2)+ ((2/(6*(x**3)))*(x-1)**3)-((6/(24*(x**4)))*(x-1)**4)

```

:::

:::{.small_font}

```{python}
#| echo: true
#| eval: true
#| output: true

print(taylor_expansion_ln(1.1))


```

:::



## Ejemplo de Error de truncamiento

::: {.callout-warning title="Recordemos" collapsible="false"}

$$R_n\left( x \right) = \frac{f^{\left( n+1 \right)}\left( \xi \right)}{\left( n+1 \right)!}\left( x-c \right)^{n+1}$$

:::

::: {.callout-note title="Error en forma de lagrange" collapsible="false"}

$$R_4\left(1.1\right) = \frac{24\xi^{-5}}{5!}\left(1.1 - 1\right)^{5}$$

:::


:::{.small_font}

```{python}
#| echo: true
#| eval: true
#| output: true

def error_taylor_expansion(x):
    return ((24*x**(-5))/120)*(0.1**5)

```



:::


## Ejemplo de Error de truncamiento

:::{.center .small_font}

```{python}
#| echo: true
#| eval: true
#| output: true
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt

v = np.arange(1,1.1,0.0001)
error = error_taylor_expansion(v)
fig, ax = plt.subplots()
ax.plot(v,error)
ax.set_xlabel("Valor")
ax.set_ylabel("Error de truncamiento")
plt.show()

```

:::


## Ejemplo de Error de truncamiento

::: {.callout-note title="Calcular ln(1.1), centrado en  c=1, y orden 4" collapsible="false"}

:::{.small_font}

  $$f\left(1.1\right)=ln\left(1\right)+\frac{1}{1}\left(1.1 - 1\right)-\frac{1}{2\cdot 1^2}\left(1.1-1\right)^2+\frac{2}{6\cdot 1^3}\left(1.1 - 1\right)^3 - \frac{6}{24\cdot 1^4}\left(1.1 - 1\right)^4$$

:::



:::

:::{.small_font}

```{python}
#| echo: true
#| eval: true
#| output: true

def taylor_expansion_ln(x):
    return ((1/1)*(x-1))-((1/(2*(1**2)))*(x-1)**2)+ ((2/(6*(1**3)))*(x-1)**3)-((6/(24*(1**4)))*(x-1)**4)

```

:::

:::{.small_font}

```{python}
#| echo: true
#| eval: true
#| output: true

print(taylor_expansion_ln(1.1))


```

:::


## Error de redondeo



::: {.callout-important title="Supongamos..." collapsible="false"}

$$x=\frac{5}{7}$$
$$y = \frac{1}{3}$$

1. Calcular x+y utilizando aritmética de digitos finitos, utilizando 6 cifras significativas, considerando:
  
    - Método de truncamiento
    - Método de redondeo

2. Calcular el error para todos los casos anteriores
:::

## Error de redondeo{.scrollable}

::: columns

:::{.column width="50%"}

```{python}
#| echo: true
#| eval: true
#| output: true

print(5.0/7.0)

```

Utilizando redondeo...

$$x=0.714286\times10^0$$

:::

:::{.column width="50%"}

```{python}
#| echo: true
#| eval: true
#| output: true

print(1.0/3.0)

```

Utilizando redondeo...

$$x=0.333333\times10^0$$

:::

:::

$$x+y=0.104762\times10^{1}$$

```{python}
#| echo: true
#| eval: true
#| output: true

print( "Error absoluto:", abs(((22.0/21.0) - (1.04762))) )
print( "Error relativo:", abs(((22.0/21.0) - (1.04762))/((22.0/21.0))) )

```

## Error de redondeo{.scrollable}

::: columns

:::{.column width="50%"}

```{python}
#| echo: true
#| eval: true
#| output: true

print(5.0/7.0)

```

Utilizando truncamiento...

$$x=0.714285\times10^0$$

:::

:::{.column width="50%"}

```{python}
#| echo: true
#| eval: true
#| output: true

print(1.0/3.0)

```

Utilizando truncamiento...

$$x=0.333333\times10^0$$

:::

:::

$$x+y=0.104761\times10^{1}$$

```{python}
#| echo: true
#| eval: true
#| output: true

print( "Error absoluto:", abs(((22.0/21.0) - (1.04761))) )
print( "Error relativo:", abs(((22.0/21.0) - (1.04761))/((22.0/21.0))) )

```

<!-- TODO:algoritmos y convergencia-Seción 1.3 de Burden  -->

## Búsqueda de \"raíces\" de una función

::: {.callout-note title="Definicón" collapsible="false"}

Las raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\left(c\right)=0$

:::

::: columns

:::{.column width="50%"}

::: {.callout-warning title="Ejemplo 1" collapsible="false"}

La raiz de la función $f\left(x\right) = 3x-4$ es $x=\frac{4}{3}$

:::

:::

:::{.column width="50%"}

::: {.callout-warning title="Ejemplo 2" collapsible="false"}

Los ceros de la función $f\left(x\right) = x^2 -x -6$ son $x=3$ y $x=-2$

:::



:::

:::

## Búsqueda de \"raíces\" de una función

::: {.callout-note title="Definicón" collapsible="false"}

Las raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\left(c\right)=0$

:::

::: columns

:::{.column width="50%"}

::: {.callout-warning title="Ejemplo 1" collapsible="false"}

La raiz de la función $f\left(x\right) = 3x-4$ es $x=\frac{4}{3}$

:::

:::

:::{.column width="50%"}


```{python}
#| echo: true
#| eval: true
#| output: false

import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0,2,0.01)
f_x = 3*x-4
fig, ax = plt.subplots()
ax.plot(x, f_x)
plt.grid(True)
plt.show()

```




:::

:::

## Búsqueda de \"raíces\" de una función

::: {.callout-note title="Definicón" collapsible="false"}

Las raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\left(c\right)=0$

:::

::: columns

:::{.column width="50%"}

::: {.callout-warning title="Ejemplo 1" collapsible="false"}

La raiz de la función $f\left(x\right) = 3x-4$ es $x=\frac{4}{3}$

:::

:::

:::{.column width="50%"}


```{python}
#| echo: false
#| eval: true
#| output: true

import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0,2,0.01)
f_x = 3*x-4
fig, ax = plt.subplots()
ax.plot(x, f_x)
plt.grid(True)
plt.show()

```




:::

:::

## Búsqueda de \"raíces\" de una función

::: {.callout-note title="Definicón" collapsible="false"}

Las raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\left(c\right)=0$

:::

::: columns

:::{.column width="50%"}


```{python}
#| echo: true
#| eval: true
#| output: false

import numpy as np
import matplotlib.pyplot as plt

t = np.arange(-3,4, 0.01)
f_t = (t**2)-(t)-6

fig, ax = plt.subplots()
ax.plot(t, f_t)
plt.grid(True)
plt.show()

```




:::

:::{.column width="50%"}

::: {.callout-warning title="Ejemplo 2" collapsible="false"}

Los ceros de la función $f\left(x\right) = x^2 -x -6$ son $x=3$ y $x=-2$

:::



:::

:::

## Búsqueda de \"raíces\" de una función

::: {.callout-note title="Definicón" collapsible="false"}

Las raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\left(c\right)=0$

:::

::: columns

:::{.column width="50%"}


```{python}
#| echo: false
#| eval: true
#| output: true

import numpy as np
import matplotlib.pyplot as plt

t = np.arange(-3,4, 0.01)
f_t = (t**2)-(t)-6

fig, ax = plt.subplots()
ax.plot(t, f_t)
plt.grid(True)
plt.show()

```



:::

:::{.column width="50%"}

::: {.callout-warning title="Ejemplo 2" collapsible="false"}

Los ceros de la función $f\left(x\right) = x^2 -x -6$ son $x=3$ y $x=-2$

:::



:::

:::

## Que pasa con funciones más complejas

En muchas ecuaciones en ciencias e ingeniería, en las cuales no es posible aplicar un procedimiento para despejar la incógnita.

::: columns

:::{.column width="50%"}

- $f\left(x\right) = x - $cos\left(x\right)$

- $f\left(x\right) = e^{-x} - sin\left(x\right)$
:::

:::{.column width="50%"}

- $f\left(x\right) = x - tan\left(x\right)$

- $f\left(x\right) = e^{x} - x$

:::

:::


## Soluciones de ecuaciones de una variable

::: columns

:::{.column width="50%"}

:::{.small_font}

A menudo, el crecimiento de una población se puede modelar sobre periodos breves al asumir que aumenta de manera continua con el tiempo a una tasa proporcional al número actual en ese momento. Suponga que $N\left(t\right)$ denota el número en la población en el tiempo t y λ denota la tasa constante de natalidad. Entonces, dicha población satisface la ecuación diferencial:

$$\frac{d N\left(t\right)}{dt}=\lambda N\left(t\right)$$

Cuya solución es $N\left(t\right)=N_0 e^{\lambda t}$

:::



:::

:::{.column width="50%"}

```{python}
#| echo: true
#| eval: true
#| output: false
import numpy as np
import matplotlib.pyplot as plt

N_o = 1e6
l_i = 0.5

t = np.arange(0,10,0.01)
N_t = N_o*np.exp(l_i*t)

fig, ax = plt.subplots()
ax.plot(t, N_t)
plt.show()
```

:::

:::


## Soluciones de ecuaciones de una variable

::: columns

:::{.column width="50%"}

:::{.small_font}

A menudo, el crecimiento de una población se puede modelar sobre periodos breves al asumir que aumenta de manera continua con el tiempo a una tasa proporcional al número actual en ese momento. Suponga que $N\left(t\right)$ denota el número en la población en el tiempo t y λ denota la tasa constante de natalidad. Entonces, dicha población satisface la ecuación diferencial:

$$\frac{d N\left(t\right)}{dt}=\lambda N\left(t\right)$$

Cuya solución es $N\left(t\right)=N_0 e^{\lambda t}$

:::



:::

:::{.column width="50%"}

```{python}
#| echo: false
#| eval: true
#| output: true
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.plot(t, N_t)
plt.show()
```


:::

:::


## Soluciones de ecuaciones de una variable

::: columns

:::{.column width="50%"}

::: {.callout-note title="Suponga que...." collapsible="false"}

Suponga que, en un inicio, cierta población contiene $N\left(0\right)=1000000$ individuos, que $\upsilon=435000$ individuos inmigran a la comunidad durante el primer año y que existen N\left(1\right)=1564000 al finalizar el año. SI deseamos determinar el la tasa de natalidad $\lambda$ se requiere encontrar las raíces de

:::{.small_font}

$$1564000 = 1000000e^{\lambda} + \frac{435000}{\lambda}\left(e^{\lambda}-1\right)$$

:::




:::



:::

:::{.column width="50%"}

```{python}
#| echo: true
#| eval: true
#| output: false
import numpy as np
import matplotlib.pyplot as plt

lam = np.arange(0,0.2,0.0001)

def f(l):
    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000

fig, ax = plt.subplots()
ax.plot(lam, f(lam))
ax.grid(True)
plt.show()
```

:::

:::


## Soluciones de ecuaciones de una variable

::: columns

:::{.column width="50%"}

::: {.callout-note title="Suponga que...." collapsible="false"}

Suponga que, en un inicio, cierta población contiene $N\left(0\right)=1000000$ individuos, que $\upsilon=435000$ individuos inmigran a la comunidad durante el primer año y que existen N\left(1\right)=1564000 al finalizar el año. SI deseamos determinar el la tasa de natalidad $\lambda$ se requiere encontrar las raíces de

:::{.small_font}

$$1564000 = 1000000e^{\lambda} + \frac{435000}{\lambda}\left(e^{\lambda}-1\right)$$

:::

:::



:::

:::{.column width="50%"}

```{python}
#| echo: false
#| eval: true
#| output: true
import numpy as np
import matplotlib.pyplot as plt

lam = np.arange(0,0.2,0.0001)

def f(l):
    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000

fig, ax = plt.subplots()
ax.plot(lam, f(lam))
ax.grid(True)
plt.show()
```

:::

:::



## Método de la bisección{.scrollable}

::: columns

:::{.column width="50%"}

```{python}
#| echo: false
#| eval: true
#| output: true

import numpy as np
import matplotlib.pyplot as plt

lam = np.arange(0.05,0.2,0.0001)

def f(l):
    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000

valor = np.array([0.05, 0.2])

fig, ax = plt.subplots()
ax.plot(lam, f(lam))
ax.stem(valor, f(valor), linefmt=':')
ax.grid(True)
plt.show()

```



:::

:::{.column width="50%"}

![](./images/NumericalAnalysis/met_biseccion.jpg)

:::

:::

## Método de la bisección

```{python}
#| echo: true
#| eval: true
#| output: true

def met_bisectriz(a,b,tol,g,No):
    i = 0
    FA = g(a)
    while i <= No:
        p = a+ ((b-a)/2)

        FP = g(p)
        if (FP==0) or (((b-a)/2)<tol):
            print("Lo logré, raíz en:", p, FP)
            return p,i
            break
        i=i+1
        if FA*FP > 0:
            a=p
            FA=FP
        else:
            b=p
    print("Termine: ", i)

```

## Método de Regula-Falsi

```{python}
#| echo: false
#| eval: true
#| output: true

def g(x):
    return np.sin(x+0.5)

lam = np.arange(-np.pi/2,np.pi/2, 0.001)

fig, ax = plt.subplots()
a = -1.2
b = 0.8
ax.plot(lam, g(lam))
ax.axhline(y=0, color="red")
ax.stem([a, b], [g(a), g(b)], linefmt=':')
ax.axline((a, g(a)), slope=(g(b)-g(a))/(b-a), color="black", linestyle='--')
ax.grid(True)
plt.show()

```


## Método de Regula-Falsi

```{python}
#| echo: true
#| eval: true
#| output: true

def met_regula_falsi(a,b,tol,g,No):
    i = 0
    FA = g(a)
    FB = g(b)
    while i <= No:
        p = a - ((FA*(b-a))/(FB-FA))
        FP = g(p)
        if (FP==0) or (((b-a)/2)<tol):
            #print("Lo logré, raíz en:", p, FP)
            return p,i
            break
        i=i+1
        if FA*FP > 0:
            a=p
            FA=FP
        else:
            b=p
            FB=FP
    print("Termine: ", i)  

```




## Método de Newton-Raphson

::: columns

:::{.column width="50%"}

```{python}
#| echo: false
#| eval: true
#| output: true
def g(x):
    return np.sin(x+0.5)

def der_g(x):
    return np.cos(x+0.5)

lam = np.arange(-np.pi/2,np.pi/2, 0.001)
p0 = 0.6
p1 = p0 - ((g(p0))/(der_g(p0)))
fig, ax = plt.subplots()
ax.plot(lam, g(lam))
ax.axhline(y=0, color="red")
ax.stem(p0, g(p0), linefmt=':')
ax.axline((p0, g(p0)), slope=der_g(p0), color="black", linestyle='--')
ax.stem(p1, g(p1), linefmt=':')
ax.axline((p1, g(p1)), slope=der_g(p1), color="green", linestyle='--')
ax.grid(True)
plt.show()

```



:::

:::{.column width="50%"}

![](./images/NumericalAnalysis/newton-raphson.jpg)

:::

:::

