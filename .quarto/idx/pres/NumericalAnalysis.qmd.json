{"title":"Análisis Numérico","markdown":{"yaml":{"title":"Análisis Numérico","description":"Sitio de la asignatura análisis numérico en la UniAutonoma del Cauca","subtitle":"Ingeniería de software y computación","lang":"es","author":"Ph.D. Pablo Eduardo Caicedo Rodríguez","date":"2023-08-01","format":{"revealjs":{"code-tools":true,"code-overflow":"scroll","code-line-numbers":true,"code-copy":false,"fig-align":"center","self-contained":true,"theme":["white","custom.scss"],"slide-number":true,"preview-links":"auto","logo":"images/medes.png","css":"styles.css","footer":"<https://pacaicedo.github.io>","transition":"fade"}},"resources":["demo.pdf"]},"headingText":"Análisis Numérico","containsRefs":false,"markdown":"\n\n\n## El Profesor {.smaller}\n\n::: columns\n\n:::: column\n\n\n### Educación\n\nDoctor en Ciencias de la Electrónica.\nMagíster en Ingeniería Electrónica y Telecomunicaciones\nIngeniero en Electrónica y Telecomunicaciones\n\n### Intereses\n\nBiomecánica, Dispositivos para el análisis de movimiento humano, ciencia de los datos.\n\n::::\n\n:::: column\n\n### Desempeño\n\nProfesor de la Facultad de Ingeniería\n\nInvest. Línea de Percep. Avanz. y Robótica -- GITA\n\nDirector Grupo de Investigación MEDES.\n\nDirector del laboratorio de datos de la Uniautonoma.\n\n::::\n\n:::\n\n### Contacto:\n\npablo.caicedo.r@uniautonoma.edu.co\n\n\n## Contenido del curso\n\n:::columns\n\n:::: column\n\n![](./images/NumericalAnalysis/numerical_analysis_01.jpeg){ height=\"600\" }\n\n::::\n\n:::: column\n\n1. Introducción al análisis numérico\n2. Solución de ecuaciones\n3. Interpolación y aproximaciones lineales\n4. Diferenciación e integración numérica\n5. Problemas de valor inicial para solución de ecuaciones diferenciales ordinarias\n\n::::\n\n:::\n\n## Evaluación\n\n:::columns\n\n:::: column\n\n\\scriptsize\n\n1. Comprensión de lectura (Inglés) (10%)\n2. Consigna 001. Solución de ecuaciones - Interpolación y aproximaciones lineales (25%)\n2. Consigna 002. Diferenciación e integración numérica (25%)\n3. Consigna 003. Proyecto Final (40%)\n\n\\normalsize\n\n::::\n\n:::: column\n\n![](images/evaluacion.jpg)\n\n::::\n\n:::\n\n\n## Recursos\n\n### Clases\n\nLunes, Martes, Miércoles y Jueves\n9:00 -- 11:00\nSala 504\n\n[Sala de teams](https://teams.microsoft.com/l/channel/19%3aXtToBJm4BKK4XyFP47UVcSYBhCR1JosQE-qQ6Kk6TKE1%40thread.tacv2/General?groupId=928c3615-fd66-4e37-92de-5b85feb03424&tenantId=c91fc68b-7571-4551-933c-467a6c58bf58)\n\n\n### Software\n**Interpretes:** Python, R, Latex(TEXLive), Anaconda.\n\n**IDE:** Visual Studio Code, Google Colaboratory ([R](https://colab.to/r), [Python](https://colab.to))\n\n**Librerías** Numpy.\n\n**Seguimiento de Aprendizaje:** Moodle\n\n\n## Bibliografía{.scrollable}\n\n\n1. Angarita, A. (2013). Apuntes De Análisis Numérico. Departamento de Ciencias Básicas - Unidades Tecnológicas de Santander.\n2. Burden, R. L., Faires, J. D., & Burden, A. M. (2016). Análisis Numérico (Tenth edition). Cengage Learning.\n3. Chapra, S. C., Canale, R. P., & Del Valle Sotelo, J. C. (2008). Métodos numéricos para ingenieros (5a ed). McGraw-Hill.\n4. Arévalo Ovalle, D., Bernal Yermanos, M. Á., & Posada Restrepo, J. A. (2021). Métodos numéricos con Python. Editorial Politécnico Grancolombiano.\n5. Corriou, J.-P. (2021). Numerical Methods and Optimization: Theory and Practice for Engineers (Vol. 187). Springer International Publishing. https://doi.org/10.1007/978-3-030-89366-8\n6. Gilat, A., & Subramaniam, V. (2014). Numerical methods for engineers and scientists: An introduction with applications using matlab (Third edition). John Wiley & Sons, Inc.\n7. Miles, W. (2023). Numerical Methods with Python: For the sciences (1st ed.). De Gruyter.\n\n\n\n# Introducción al análisis numérico\n\n## Errores y aproximaciones\n\n::: columns\n\n:::{.column width=\"50%\"}\n\nLas cantidades que se trabajan en la ingeniería tienen dos orígenes diferentes:\n\n- Mediciones sobre procesos físicos\n- Resultados de procesos matemáticos.\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Primer Origen\" collapse=\"false\"}\n\nUn proceso de medición nunca arroja el valor verdadero de la medida, pues las mediciones se hacen con instrumentos que se encuentran limitados\n\n:::\n\n::: {.callout-important title=\"Segundo Origen\" collapse=\"false\"}\n\nLas operaciones aritméticas usualmente se ejecutan en un computador o una calculadora, y la limitación de espacio de estos dispositivos lleva a que algunas cifras no se puedan representar correctamente.\n\n:::\n\n\n\n:::\n\n:::\n\n\n## Errores y aproximaciones\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\nLos errores debido a estos orígenes es de naturaleza acumulativa, por ejemplo si se operan medidas reales con un procesador limitado la incertidumbre aumentará.\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\nMuchas veces resulta imposible siquiera expresar en términos algebraicos soluciones a ciertas ecuaciones, inclusive polinomiales.\n\n:::\n\n\n\n:::\n\n:::\n\n::: {.callout-tip title=\"Siempre...\" collapsible=\"false\"}\n\nCon lo anterior, es claro que el trabajo de ingeniería y ciencias se encuentra inevitablemente sujeto a error, y por tanto el tema de cuantificación de errores es de atención prioritaria en dichas áreas.\n\n:::\n\n## Errores y aproximaciones\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n### Error Absoluto\n\n$$\\varepsilon = \\left| x - \\bar{x} \\right|$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n### Error relativo\n\n$$\\varepsilon_{\\gamma} = \\frac{\\left| x - \\bar{x} \\right|}{\\left| x \\right|}$$\n\n:::\n\n:::\n\n### Error de aproximación\n\n$$\\varepsilon_{ap} = {\\left| x_{actual} - x_{anterior} \\right|}$$\n\n\n## Cifras significativas\n\n![](./images/NumericalAnalysis/cifras_significativas.png)\n\n\n## Cifras significativas\n\n::: {.callout-tip title=\"Considere...\" collapsible=\"false\"}\n\nUna región rectangular que tiene 20.5 cm de largo por 14.3 cm de ancho. Se requiere la medida del área de la región en centímetros cuadrados.\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n![](./images/NumericalAnalysis/cifras_significativas.png)\n\n:::\n\n:::{.column width=\"50%\"}\n\n:::{.small_font}\n\n- Diferentes personas reportarían sin dudar los primeros dos dígitos, a saber el dos y el cero, que en este contexto se llamarán dígitos confiables.\n\n- Se entenderá que esta medida en realidad es una cifra entre 20.5 cm y 20.6 cm con el tercer dígito llamado dígito de incertidumbre.\n\n- La cantidad de dígitos confiables más otro con incertidumbre, son las cifras significativas de una medición.\n\n:::\n\n\n\n:::\n\n:::\n\n\n## Cifras significativas\n\n::: {.callout-note title=\"¿Que pasa con las operaciones?\" collapsible=\"false\"}\n\nCuando se operen números con cifras significativas, el resultado tendrá tantas cifras significativas como el factor con menos cifras significativas.\n\n:::\n\n::: {.callout-important title=\"Hablando de errores\" collapsible=\"false\"}\n\nCon el número de cifras significativas $\\left(n\\right)$, se puede calcular la cota del error absoluto:\n\n$$\\varepsilon = \\left( 0.5\\times10^{2-n} \\right) \\%$$\n\n:::\n\n\n## Que pasa en los computadores?\n\n![](./images/NumericalAnalysis//cifras_significativas_ieee.png)\n\n$$\\left(-1\\right)^{s}2^{c-1023}\\left(1+f\\right)$$\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nEl bit más izquierdo en ambos casos es \"0\", por lo tanto en los dos casos los numéros son positivos.\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nEn el ambos casos el exponente es _10000000011_ por lo tanto el valor c se calcula así:\n\n:::{.small_font}\n\n$$ c = 1 \\cdot 2^{10} + 0 \\cdot 2^{9} + \\dots +1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 1024+2+1=1027$$\n\n:::\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nLa mantisa para el primer caso es:\n\n:::{.small_font}\n\n\n$$1011100100010000000000000000000000000000000000000000$$\n$$ f = 1 \\cdot 2^{-1} + 1 \\cdot 2^{-3} + 1\\cdot 2^{-4} +1 \\cdot 2^{-5} + 1 \\cdot 2^{-8} + 1 \\cdot 2^{-12} $$\n$$ f = 0.5 + 0.125 + 0.0625 + 0.03125 + 0.00390625 + 0.000244140625$$\n$$ f= 0.7229003906250000000000$$\n\n:::\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nLa mantisa para el segundo caso es:\n\n:::{.small_font}\n\n\n$$1011100100010000000000000000000000000000000000000001$$\n$$ f = 1 \\cdot 2^{-1} + 1 \\cdot 2^{-3} + 1\\cdot 2^{-4} +1 \\cdot 2^{-5} + 1 \\cdot 2^{-8} + 1 \\cdot 2^{-12} + 1 \\cdot 2^{-52}$$\n$$ f = 0.5 + 0.125 + 0.0625 + 0.03125 + 0.00390625 + 0.000244140625 + 2,220476049250313e-16$$\n$$f = 0.7229003906250002220446$$\n\n:::\n\n## Los números \\\"más grande\\\" y \\\"más pequeño\\\"\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\n- **Más grande:** Sucede cuando $s=0$, $c=2046$, $f=1-2^{-52}$\n- **Más pequeño:** Sucede cuando $s=0$, $c=1$, $f=0$\n\n:::\n\n## Error de truncamiento\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\nDentro de los números reales $\\left( \\mathbb{R} \\right)$, existen dos conjuntos de números claramente diferenciables, los racionales $\\left( \\mathbb{Q} \\right)$ y los irracionales $\\left( \\mathbb{I} \\right)$. Los primeros son facilmente representables en un sistema computacional; sin embargo los segundo debido a que no pueden ser representados con un número finito de digitos deben ser cortados a unas cuantas cifras.\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Nota\" collapsible=\"false\"}\n\nSin embargo, hay formas metódicas de obtener aproximaciones tan buenas como se quieran a estos números. Como por ejemplo las conocidas series de Taylor \n\n:::{.x_small_font}\n$$f\\left( x \\right) = f\\left( c \\right) + \\dot{f}\\left( c \\right)\\left( x-c \\right) + \\frac{\\ddot{f}\\left( c \\right)}{2!}\\left( x-c \\right)^2 + \\frac{\\dddot{f}\\left( c \\right)}{3!}\\left( x-c \\right)^3 + \\dots + \\frac{f^{\\left(n\\right)}\\left( c \\right)}{n!}\\left( x-c \\right)^n$$\n:::\n\n- Todas las derivadas deben existir.\n- Función y derivadas  en el intervalo $\\left(x,c\\right)$\n\n:::\n\n:::\n\n:::\n\n## Error de truncamiento  \n\n::: {.callout-note title=\"Forma de Langrange\" collapsible=\"false\"}\n\n$$R_n\\left( x \\right) = \\frac{f^{\\left( n+1 \\right)}\\left( \\xi \\right)}{\\left( n+1 \\right)!}\\left( x-c \\right)^{n+1}$$\n\n:::\n\n::: {.callout-note title=\"Forma Integral\" collapsible=\"false\"}\n\n$$R_n\\left( x \\right) = \\int_{c}^{x}{\\frac{f^{\\left(n+1\\right)}\\left(t\\right)}{n!}\\left(x-t\\right)^{n}dt}$$\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n\n::: {.callout-warning title=\"Recordemos\" collapsible=\"false\"}\n\n:::{.small_font}\n\n$$f\\left( x \\right) = f\\left( c \\right) + \\dot{f}\\left( c \\right)\\left( x-c \\right) + \\frac{\\ddot{f}\\left( c \\right)}{2!}\\left( x-c \\right)^2 + \\frac{\\dddot{f}\\left( c \\right)}{3!}\\left( x-c \\right)^3 + \\dots + \\frac{f^{\\left(n\\right)}\\left( c \\right)}{n!}\\left( x-c \\right)^n$$\n  \n\n:::\n\n\n\n:::\n\n\n\n::: {.callout-note title=\"Calcular ln(1.1), centrado en  c=1, y orden 4\" collapsible=\"false\"}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n$$f\\left(x\\right)=ln\\left(x\\right)$$\n\n$$\\dot{f}\\left(x\\right) = \\frac{1}{x}$$\n\n$$\\ddot{f}\\left(x\\right) = -\\frac{1}{x^2}$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n\n$$\\dddot{f}\\left(x\\right) = \\frac{2}{x^3}$$\n\n$$\\ddddot{f}\\left(x\\right) = -\\frac{6}{x^4}$$\n\n:::\n\n:::\n\n\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n::: {.callout-note title=\"Calcular ln(1.1), centrado en  c=1, y orden 4\" collapsible=\"false\"}\n\n:::{.small_font}\n\n  $$f\\left(1.1\\right)=ln\\left(1\\right)+\\frac{1}{1.1}\\left(1.1 - 1\\right)-\\frac{1}{2\\cdot 1.1^2}\\left(1.1-1\\right)^2+\\frac{2}{6\\cdot 1.1^3}\\left(1.1 - 1\\right)^3 - \\frac{6}{24\\cdot 1.1^4}\\left(1.1 - 1\\right)^4$$\n\n:::\n\n\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef taylor_expansion_ln(x):\n    return ((1/x)*(x-1))-((1/(2*(x**2)))*(x-1)**2)+ ((2/(6*(x**3)))*(x-1)**3)-((6/(24*(x**4)))*(x-1)**4)\n\n```\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(taylor_expansion_ln(1.1))\n\n\n```\n\n:::\n\n\n\n## Ejemplo de Error de truncamiento\n\n::: {.callout-warning title=\"Recordemos\" collapsible=\"false\"}\n\n$$R_n\\left( x \\right) = \\frac{f^{\\left( n+1 \\right)}\\left( \\xi \\right)}{\\left( n+1 \\right)!}\\left( x-c \\right)^{n+1}$$\n\n:::\n\n::: {.callout-note title=\"Error en forma de lagrange\" collapsible=\"false\"}\n\n$$R_4\\left(1.1\\right) = \\frac{24\\xi^{-5}}{5!}\\left(1.1 - 1\\right)^{5}$$\n\n:::\n\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef error_taylor_expansion(x):\n    return ((24*x**(-5))/120)*(0.1**5)\n\n```\n\n\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n:::{.center .small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n#| fig-align: center\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nv = np.arange(1,1.1,0.0001)\nerror = error_taylor_expansion(v)\nfig, ax = plt.subplots()\nax.plot(v,error)\nax.set_xlabel(\"Valor\")\nax.set_ylabel(\"Error de truncamiento\")\nplt.show()\n\n```\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n::: {.callout-note title=\"Calcular ln(1.1), centrado en  c=1, y orden 4\" collapsible=\"false\"}\n\n:::{.small_font}\n\n  $$f\\left(1.1\\right)=ln\\left(1\\right)+\\frac{1}{1}\\left(1.1 - 1\\right)-\\frac{1}{2\\cdot 1^2}\\left(1.1-1\\right)^2+\\frac{2}{6\\cdot 1^3}\\left(1.1 - 1\\right)^3 - \\frac{6}{24\\cdot 1^4}\\left(1.1 - 1\\right)^4$$\n\n:::\n\n\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef taylor_expansion_ln(x):\n    return ((1/1)*(x-1))-((1/(2*(1**2)))*(x-1)**2)+ ((2/(6*(1**3)))*(x-1)**3)-((6/(24*(1**4)))*(x-1)**4)\n\n```\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(taylor_expansion_ln(1.1))\n\n\n```\n\n:::\n\n\n## Error de redondeo\n\n\n\n::: {.callout-important title=\"Supongamos...\" collapsible=\"false\"}\n\n$$x=\\frac{5}{7}$$\n$$y = \\frac{1}{3}$$\n\n1. Calcular x+y utilizando aritmética de digitos finitos, utilizando 6 cifras significativas, considerando:\n  \n    - Método de truncamiento\n    - Método de redondeo\n\n2. Calcular el error para todos los casos anteriores\n:::\n\n## Error de redondeo{.scrollable}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(5.0/7.0)\n\n```\n\nUtilizando redondeo...\n\n$$x=0.714286\\times10^0$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(1.0/3.0)\n\n```\n\nUtilizando redondeo...\n\n$$x=0.333333\\times10^0$$\n\n:::\n\n:::\n\n$$x+y=0.104762\\times10^{1}$$\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint( \"Error absoluto:\", abs(((22.0/21.0) - (1.04762))) )\nprint( \"Error relativo:\", abs(((22.0/21.0) - (1.04762))/((22.0/21.0))) )\n\n```\n\n## Error de redondeo{.scrollable}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(5.0/7.0)\n\n```\n\nUtilizando truncamiento...\n\n$$x=0.714285\\times10^0$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(1.0/3.0)\n\n```\n\nUtilizando truncamiento...\n\n$$x=0.333333\\times10^0$$\n\n:::\n\n:::\n\n$$x+y=0.104761\\times10^{1}$$\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint( \"Error absoluto:\", abs(((22.0/21.0) - (1.04761))) )\nprint( \"Error relativo:\", abs(((22.0/21.0) - (1.04761))/((22.0/21.0))) )\n\n```\n\n<!-- TODO:algoritmos y convergencia-Seción 1.3 de Burden  -->\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 1\" collapsible=\"false\"}\n\nLa raiz de la función $f\\left(x\\right) = 3x-4$ es $x=\\frac{4}{3}$\n\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 2\" collapsible=\"false\"}\n\nLos ceros de la función $f\\left(x\\right) = x^2 -x -6$ son $x=3$ y $x=-2$\n\n:::\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 1\" collapsible=\"false\"}\n\nLa raiz de la función $f\\left(x\\right) = 3x-4$ es $x=\\frac{4}{3}$\n\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(0,2,0.01)\nf_x = 3*x-4\nfig, ax = plt.subplots()\nax.plot(x, f_x)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 1\" collapsible=\"false\"}\n\nLa raiz de la función $f\\left(x\\right) = 3x-4$ es $x=\\frac{4}{3}$\n\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(0,2,0.01)\nf_x = 3*x-4\nfig, ax = plt.subplots()\nax.plot(x, f_x)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.arange(-3,4, 0.01)\nf_t = (t**2)-(t)-6\n\nfig, ax = plt.subplots()\nax.plot(t, f_t)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 2\" collapsible=\"false\"}\n\nLos ceros de la función $f\\left(x\\right) = x^2 -x -6$ son $x=3$ y $x=-2$\n\n:::\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.arange(-3,4, 0.01)\nf_t = (t**2)-(t)-6\n\nfig, ax = plt.subplots()\nax.plot(t, f_t)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 2\" collapsible=\"false\"}\n\nLos ceros de la función $f\\left(x\\right) = x^2 -x -6$ son $x=3$ y $x=-2$\n\n:::\n\n\n\n:::\n\n:::\n\n## Que pasa con funciones más complejas\n\nEn muchas ecuaciones en ciencias e ingeniería, en las cuales no es posible aplicar un procedimiento para despejar la incógnita.\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n- $f\\left(x\\right) = x - $cos\\left(x\\right)$\n\n- $f\\left(x\\right) = e^{-x} - sin\\left(x\\right)$\n:::\n\n:::{.column width=\"50%\"}\n\n- $f\\left(x\\right) = x - tan\\left(x\\right)$\n\n- $f\\left(x\\right) = e^{x} - x$\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n:::{.small_font}\n\nA menudo, el crecimiento de una población se puede modelar sobre periodos breves al asumir que aumenta de manera continua con el tiempo a una tasa proporcional al número actual en ese momento. Suponga que $N\\left(t\\right)$ denota el número en la población en el tiempo t y λ denota la tasa constante de natalidad. Entonces, dicha población satisface la ecuación diferencial:\n\n$$\\frac{d N\\left(t\\right)}{dt}=\\lambda N\\left(t\\right)$$\n\nCuya solución es $N\\left(t\\right)=N_0 e^{\\lambda t}$\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN_o = 1e6\nl_i = 0.5\n\nt = np.arange(0,10,0.01)\nN_t = N_o*np.exp(l_i*t)\n\nfig, ax = plt.subplots()\nax.plot(t, N_t)\nplt.show()\n```\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n:::{.small_font}\n\nA menudo, el crecimiento de una población se puede modelar sobre periodos breves al asumir que aumenta de manera continua con el tiempo a una tasa proporcional al número actual en ese momento. Suponga que $N\\left(t\\right)$ denota el número en la población en el tiempo t y λ denota la tasa constante de natalidad. Entonces, dicha población satisface la ecuación diferencial:\n\n$$\\frac{d N\\left(t\\right)}{dt}=\\lambda N\\left(t\\right)$$\n\nCuya solución es $N\\left(t\\right)=N_0 e^{\\lambda t}$\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.plot(t, N_t)\nplt.show()\n```\n\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Suponga que....\" collapsible=\"false\"}\n\nSuponga que, en un inicio, cierta población contiene $N\\left(0\\right)=1000000$ individuos, que $\\upsilon=435000$ individuos inmigran a la comunidad durante el primer año y que existen N\\left(1\\right)=1564000 al finalizar el año. SI deseamos determinar el la tasa de natalidad $\\lambda$ se requiere encontrar las raíces de\n\n:::{.small_font}\n\n$$1564000 = 1000000e^{\\lambda} + \\frac{435000}{\\lambda}\\left(e^{\\lambda}-1\\right)$$\n\n:::\n\n\n\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlam = np.arange(0,0.2,0.0001)\n\ndef f(l):\n    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000\n\nfig, ax = plt.subplots()\nax.plot(lam, f(lam))\nax.grid(True)\nplt.show()\n```\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Suponga que....\" collapsible=\"false\"}\n\nSuponga que, en un inicio, cierta población contiene $N\\left(0\\right)=1000000$ individuos, que $\\upsilon=435000$ individuos inmigran a la comunidad durante el primer año y que existen N\\left(1\\right)=1564000 al finalizar el año. SI deseamos determinar el la tasa de natalidad $\\lambda$ se requiere encontrar las raíces de\n\n:::{.small_font}\n\n$$1564000 = 1000000e^{\\lambda} + \\frac{435000}{\\lambda}\\left(e^{\\lambda}-1\\right)$$\n\n:::\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlam = np.arange(0,0.2,0.0001)\n\ndef f(l):\n    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000\n\nfig, ax = plt.subplots()\nax.plot(lam, f(lam))\nax.grid(True)\nplt.show()\n```\n\n:::\n\n:::\n\n\n\n## Método de la bisección{.scrollable}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlam = np.arange(0.05,0.2,0.0001)\n\ndef f(l):\n    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000\n\nvalor = np.array([0.05, 0.2])\n\nfig, ax = plt.subplots()\nax.plot(lam, f(lam))\nax.stem(valor, f(valor), linefmt=':')\nax.grid(True)\nplt.show()\n\n```\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n![](./images/NumericalAnalysis/met_biseccion.jpg)\n\n:::\n\n:::\n\n## Método de la bisección\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef met_bisectriz(a,b,tol,g,No):\n    i = 0\n    FA = g(a)\n    while i <= No:\n        p = a+ ((b-a)/2)\n\n        FP = g(p)\n        if (FP==0) or (((b-a)/2)<tol):\n            print(\"Lo logré, raíz en:\", p, FP)\n            return p,i\n            break\n        i=i+1\n        if FA*FP > 0:\n            a=p\n            FA=FP\n        else:\n            b=p\n    print(\"Termine: \", i)\n\n```\n\n## Método de Regula-Falsi\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\ndef g(x):\n    return np.sin(x+0.5)\n\nlam = np.arange(-np.pi/2,np.pi/2, 0.001)\n\nfig, ax = plt.subplots()\na = -1.2\nb = 0.8\nax.plot(lam, g(lam))\nax.axhline(y=0, color=\"red\")\nax.stem([a, b], [g(a), g(b)], linefmt=':')\nax.axline((a, g(a)), slope=(g(b)-g(a))/(b-a), color=\"black\", linestyle='--')\nax.grid(True)\nplt.show()\n\n```\n\n\n## Método de Regula-Falsi\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef met_regula_falsi(a,b,tol,g,No):\n    i = 0\n    FA = g(a)\n    FB = g(b)\n    while i <= No:\n        p = a - ((FA*(b-a))/(FB-FA))\n        FP = g(p)\n        if (FP==0) or (((b-a)/2)<tol):\n            #print(\"Lo logré, raíz en:\", p, FP)\n            return p,i\n            break\n        i=i+1\n        if FA*FP > 0:\n            a=p\n            FA=FP\n        else:\n            b=p\n            FB=FP\n    print(\"Termine: \", i)  \n\n```\n\n\n\n\n## Método de Newton-Raphson\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\ndef g(x):\n    return np.sin(x+0.5)\n\ndef der_g(x):\n    return np.cos(x+0.5)\n\nlam = np.arange(-np.pi/2,np.pi/2, 0.001)\np0 = 0.6\np1 = p0 - ((g(p0))/(der_g(p0)))\nfig, ax = plt.subplots()\nax.plot(lam, g(lam))\nax.axhline(y=0, color=\"red\")\nax.stem(p0, g(p0), linefmt=':')\nax.axline((p0, g(p0)), slope=der_g(p0), color=\"black\", linestyle='--')\nax.stem(p1, g(p1), linefmt=':')\nax.axline((p1, g(p1)), slope=der_g(p1), color=\"green\", linestyle='--')\nax.grid(True)\nplt.show()\n\n```\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n![](./images/NumericalAnalysis/newton-raphson.jpg)\n\n:::\n\n:::\n\n\n\n## Taller\n\n::: {.callout-note title=\"Pregunta 1/2\" collapsible=\"false\"}\n\nDada la función $f\\left(x\\right) = 8 sin\\left(x\\right) e^{-x} - 1$ responda las siguientes cuestiones:\n\n1. Si se sabe que $x \\in \\left[0,3\\right]$, encuentre una raíz de la función. ¿Es utilizable el método de la bisección en el cálculo de la raíz?\n\n2. Aplique Newton-Raphson para dos posibles valores iniciales: -5, 10. Cual es el resultado de la operación. Explique su resultado.\n\n:::\n\n## Taller\n\n::: {.callout-note title=\"Pregunta 2/2\" collapsible=\"false\"}\n\nLa velocidad de un para caídista esta dada por la siguiente función:\n\n$$v=\\frac{gm}{c}\\left(1 - e^{-\\frac{c}{m}t}\\right)$$\n\nSea la gravedad $g=9.8$, el coeficiente de rozamiento $c=14Kg/s$, responda:\n\n1. Cuál es el peso del paracaidista si se sabe que a los 7sg la velocidad de este era de $35m/s$ ?\n\n2. Utilizando una [calculadora de gravedad](https://www.sensorsone.com/local-gravity-calculator/), determine la gravedad real, si el experimento se hace en la ciudad de Popayán, vuelva a determinar la masa del paracaidista. Explique la discrepancia.\n\n:::\n\n","srcMarkdownNoYaml":"\n\n# Análisis Numérico\n\n## El Profesor {.smaller}\n\n::: columns\n\n:::: column\n\n\n### Educación\n\nDoctor en Ciencias de la Electrónica.\nMagíster en Ingeniería Electrónica y Telecomunicaciones\nIngeniero en Electrónica y Telecomunicaciones\n\n### Intereses\n\nBiomecánica, Dispositivos para el análisis de movimiento humano, ciencia de los datos.\n\n::::\n\n:::: column\n\n### Desempeño\n\nProfesor de la Facultad de Ingeniería\n\nInvest. Línea de Percep. Avanz. y Robótica -- GITA\n\nDirector Grupo de Investigación MEDES.\n\nDirector del laboratorio de datos de la Uniautonoma.\n\n::::\n\n:::\n\n### Contacto:\n\npablo.caicedo.r@uniautonoma.edu.co\n\n\n## Contenido del curso\n\n:::columns\n\n:::: column\n\n![](./images/NumericalAnalysis/numerical_analysis_01.jpeg){ height=\"600\" }\n\n::::\n\n:::: column\n\n1. Introducción al análisis numérico\n2. Solución de ecuaciones\n3. Interpolación y aproximaciones lineales\n4. Diferenciación e integración numérica\n5. Problemas de valor inicial para solución de ecuaciones diferenciales ordinarias\n\n::::\n\n:::\n\n## Evaluación\n\n:::columns\n\n:::: column\n\n\\scriptsize\n\n1. Comprensión de lectura (Inglés) (10%)\n2. Consigna 001. Solución de ecuaciones - Interpolación y aproximaciones lineales (25%)\n2. Consigna 002. Diferenciación e integración numérica (25%)\n3. Consigna 003. Proyecto Final (40%)\n\n\\normalsize\n\n::::\n\n:::: column\n\n![](images/evaluacion.jpg)\n\n::::\n\n:::\n\n\n## Recursos\n\n### Clases\n\nLunes, Martes, Miércoles y Jueves\n9:00 -- 11:00\nSala 504\n\n[Sala de teams](https://teams.microsoft.com/l/channel/19%3aXtToBJm4BKK4XyFP47UVcSYBhCR1JosQE-qQ6Kk6TKE1%40thread.tacv2/General?groupId=928c3615-fd66-4e37-92de-5b85feb03424&tenantId=c91fc68b-7571-4551-933c-467a6c58bf58)\n\n\n### Software\n**Interpretes:** Python, R, Latex(TEXLive), Anaconda.\n\n**IDE:** Visual Studio Code, Google Colaboratory ([R](https://colab.to/r), [Python](https://colab.to))\n\n**Librerías** Numpy.\n\n**Seguimiento de Aprendizaje:** Moodle\n\n\n## Bibliografía{.scrollable}\n\n\n1. Angarita, A. (2013). Apuntes De Análisis Numérico. Departamento de Ciencias Básicas - Unidades Tecnológicas de Santander.\n2. Burden, R. L., Faires, J. D., & Burden, A. M. (2016). Análisis Numérico (Tenth edition). Cengage Learning.\n3. Chapra, S. C., Canale, R. P., & Del Valle Sotelo, J. C. (2008). Métodos numéricos para ingenieros (5a ed). McGraw-Hill.\n4. Arévalo Ovalle, D., Bernal Yermanos, M. Á., & Posada Restrepo, J. A. (2021). Métodos numéricos con Python. Editorial Politécnico Grancolombiano.\n5. Corriou, J.-P. (2021). Numerical Methods and Optimization: Theory and Practice for Engineers (Vol. 187). Springer International Publishing. https://doi.org/10.1007/978-3-030-89366-8\n6. Gilat, A., & Subramaniam, V. (2014). Numerical methods for engineers and scientists: An introduction with applications using matlab (Third edition). John Wiley & Sons, Inc.\n7. Miles, W. (2023). Numerical Methods with Python: For the sciences (1st ed.). De Gruyter.\n\n\n\n# Introducción al análisis numérico\n\n## Errores y aproximaciones\n\n::: columns\n\n:::{.column width=\"50%\"}\n\nLas cantidades que se trabajan en la ingeniería tienen dos orígenes diferentes:\n\n- Mediciones sobre procesos físicos\n- Resultados de procesos matemáticos.\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Primer Origen\" collapse=\"false\"}\n\nUn proceso de medición nunca arroja el valor verdadero de la medida, pues las mediciones se hacen con instrumentos que se encuentran limitados\n\n:::\n\n::: {.callout-important title=\"Segundo Origen\" collapse=\"false\"}\n\nLas operaciones aritméticas usualmente se ejecutan en un computador o una calculadora, y la limitación de espacio de estos dispositivos lleva a que algunas cifras no se puedan representar correctamente.\n\n:::\n\n\n\n:::\n\n:::\n\n\n## Errores y aproximaciones\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\nLos errores debido a estos orígenes es de naturaleza acumulativa, por ejemplo si se operan medidas reales con un procesador limitado la incertidumbre aumentará.\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\nMuchas veces resulta imposible siquiera expresar en términos algebraicos soluciones a ciertas ecuaciones, inclusive polinomiales.\n\n:::\n\n\n\n:::\n\n:::\n\n::: {.callout-tip title=\"Siempre...\" collapsible=\"false\"}\n\nCon lo anterior, es claro que el trabajo de ingeniería y ciencias se encuentra inevitablemente sujeto a error, y por tanto el tema de cuantificación de errores es de atención prioritaria en dichas áreas.\n\n:::\n\n## Errores y aproximaciones\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n### Error Absoluto\n\n$$\\varepsilon = \\left| x - \\bar{x} \\right|$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n### Error relativo\n\n$$\\varepsilon_{\\gamma} = \\frac{\\left| x - \\bar{x} \\right|}{\\left| x \\right|}$$\n\n:::\n\n:::\n\n### Error de aproximación\n\n$$\\varepsilon_{ap} = {\\left| x_{actual} - x_{anterior} \\right|}$$\n\n\n## Cifras significativas\n\n![](./images/NumericalAnalysis/cifras_significativas.png)\n\n\n## Cifras significativas\n\n::: {.callout-tip title=\"Considere...\" collapsible=\"false\"}\n\nUna región rectangular que tiene 20.5 cm de largo por 14.3 cm de ancho. Se requiere la medida del área de la región en centímetros cuadrados.\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n![](./images/NumericalAnalysis/cifras_significativas.png)\n\n:::\n\n:::{.column width=\"50%\"}\n\n:::{.small_font}\n\n- Diferentes personas reportarían sin dudar los primeros dos dígitos, a saber el dos y el cero, que en este contexto se llamarán dígitos confiables.\n\n- Se entenderá que esta medida en realidad es una cifra entre 20.5 cm y 20.6 cm con el tercer dígito llamado dígito de incertidumbre.\n\n- La cantidad de dígitos confiables más otro con incertidumbre, son las cifras significativas de una medición.\n\n:::\n\n\n\n:::\n\n:::\n\n\n## Cifras significativas\n\n::: {.callout-note title=\"¿Que pasa con las operaciones?\" collapsible=\"false\"}\n\nCuando se operen números con cifras significativas, el resultado tendrá tantas cifras significativas como el factor con menos cifras significativas.\n\n:::\n\n::: {.callout-important title=\"Hablando de errores\" collapsible=\"false\"}\n\nCon el número de cifras significativas $\\left(n\\right)$, se puede calcular la cota del error absoluto:\n\n$$\\varepsilon = \\left( 0.5\\times10^{2-n} \\right) \\%$$\n\n:::\n\n\n## Que pasa en los computadores?\n\n![](./images/NumericalAnalysis//cifras_significativas_ieee.png)\n\n$$\\left(-1\\right)^{s}2^{c-1023}\\left(1+f\\right)$$\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nEl bit más izquierdo en ambos casos es \"0\", por lo tanto en los dos casos los numéros son positivos.\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nEn el ambos casos el exponente es _10000000011_ por lo tanto el valor c se calcula así:\n\n:::{.small_font}\n\n$$ c = 1 \\cdot 2^{10} + 0 \\cdot 2^{9} + \\dots +1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 1024+2+1=1027$$\n\n:::\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nLa mantisa para el primer caso es:\n\n:::{.small_font}\n\n\n$$1011100100010000000000000000000000000000000000000000$$\n$$ f = 1 \\cdot 2^{-1} + 1 \\cdot 2^{-3} + 1\\cdot 2^{-4} +1 \\cdot 2^{-5} + 1 \\cdot 2^{-8} + 1 \\cdot 2^{-12} $$\n$$ f = 0.5 + 0.125 + 0.0625 + 0.03125 + 0.00390625 + 0.000244140625$$\n$$ f= 0.7229003906250000000000$$\n\n:::\n\n## Ejemplos de conversión de IEEE 754 a decimal{.scrollable}\n\n::: {.callout-note title=\"Dos numeros \\\"diferentes\\\" \" collapsible=\"false\"}\n\n1. __0 10000000011 1011100100010000000000000000000000000000000000000000__\n2. __0 10000000011 1011100100010000000000000000000000000000000000000001__\n\n:::\n\nLa mantisa para el segundo caso es:\n\n:::{.small_font}\n\n\n$$1011100100010000000000000000000000000000000000000001$$\n$$ f = 1 \\cdot 2^{-1} + 1 \\cdot 2^{-3} + 1\\cdot 2^{-4} +1 \\cdot 2^{-5} + 1 \\cdot 2^{-8} + 1 \\cdot 2^{-12} + 1 \\cdot 2^{-52}$$\n$$ f = 0.5 + 0.125 + 0.0625 + 0.03125 + 0.00390625 + 0.000244140625 + 2,220476049250313e-16$$\n$$f = 0.7229003906250002220446$$\n\n:::\n\n## Los números \\\"más grande\\\" y \\\"más pequeño\\\"\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\n- **Más grande:** Sucede cuando $s=0$, $c=2046$, $f=1-2^{-52}$\n- **Más pequeño:** Sucede cuando $s=0$, $c=1$, $f=0$\n\n:::\n\n## Error de truncamiento\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-important title=\"Importante\" collapsible=\"false\"}\n\nDentro de los números reales $\\left( \\mathbb{R} \\right)$, existen dos conjuntos de números claramente diferenciables, los racionales $\\left( \\mathbb{Q} \\right)$ y los irracionales $\\left( \\mathbb{I} \\right)$. Los primeros son facilmente representables en un sistema computacional; sin embargo los segundo debido a que no pueden ser representados con un número finito de digitos deben ser cortados a unas cuantas cifras.\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Nota\" collapsible=\"false\"}\n\nSin embargo, hay formas metódicas de obtener aproximaciones tan buenas como se quieran a estos números. Como por ejemplo las conocidas series de Taylor \n\n:::{.x_small_font}\n$$f\\left( x \\right) = f\\left( c \\right) + \\dot{f}\\left( c \\right)\\left( x-c \\right) + \\frac{\\ddot{f}\\left( c \\right)}{2!}\\left( x-c \\right)^2 + \\frac{\\dddot{f}\\left( c \\right)}{3!}\\left( x-c \\right)^3 + \\dots + \\frac{f^{\\left(n\\right)}\\left( c \\right)}{n!}\\left( x-c \\right)^n$$\n:::\n\n- Todas las derivadas deben existir.\n- Función y derivadas  en el intervalo $\\left(x,c\\right)$\n\n:::\n\n:::\n\n:::\n\n## Error de truncamiento  \n\n::: {.callout-note title=\"Forma de Langrange\" collapsible=\"false\"}\n\n$$R_n\\left( x \\right) = \\frac{f^{\\left( n+1 \\right)}\\left( \\xi \\right)}{\\left( n+1 \\right)!}\\left( x-c \\right)^{n+1}$$\n\n:::\n\n::: {.callout-note title=\"Forma Integral\" collapsible=\"false\"}\n\n$$R_n\\left( x \\right) = \\int_{c}^{x}{\\frac{f^{\\left(n+1\\right)}\\left(t\\right)}{n!}\\left(x-t\\right)^{n}dt}$$\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n\n::: {.callout-warning title=\"Recordemos\" collapsible=\"false\"}\n\n:::{.small_font}\n\n$$f\\left( x \\right) = f\\left( c \\right) + \\dot{f}\\left( c \\right)\\left( x-c \\right) + \\frac{\\ddot{f}\\left( c \\right)}{2!}\\left( x-c \\right)^2 + \\frac{\\dddot{f}\\left( c \\right)}{3!}\\left( x-c \\right)^3 + \\dots + \\frac{f^{\\left(n\\right)}\\left( c \\right)}{n!}\\left( x-c \\right)^n$$\n  \n\n:::\n\n\n\n:::\n\n\n\n::: {.callout-note title=\"Calcular ln(1.1), centrado en  c=1, y orden 4\" collapsible=\"false\"}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n$$f\\left(x\\right)=ln\\left(x\\right)$$\n\n$$\\dot{f}\\left(x\\right) = \\frac{1}{x}$$\n\n$$\\ddot{f}\\left(x\\right) = -\\frac{1}{x^2}$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n\n$$\\dddot{f}\\left(x\\right) = \\frac{2}{x^3}$$\n\n$$\\ddddot{f}\\left(x\\right) = -\\frac{6}{x^4}$$\n\n:::\n\n:::\n\n\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n::: {.callout-note title=\"Calcular ln(1.1), centrado en  c=1, y orden 4\" collapsible=\"false\"}\n\n:::{.small_font}\n\n  $$f\\left(1.1\\right)=ln\\left(1\\right)+\\frac{1}{1.1}\\left(1.1 - 1\\right)-\\frac{1}{2\\cdot 1.1^2}\\left(1.1-1\\right)^2+\\frac{2}{6\\cdot 1.1^3}\\left(1.1 - 1\\right)^3 - \\frac{6}{24\\cdot 1.1^4}\\left(1.1 - 1\\right)^4$$\n\n:::\n\n\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef taylor_expansion_ln(x):\n    return ((1/x)*(x-1))-((1/(2*(x**2)))*(x-1)**2)+ ((2/(6*(x**3)))*(x-1)**3)-((6/(24*(x**4)))*(x-1)**4)\n\n```\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(taylor_expansion_ln(1.1))\n\n\n```\n\n:::\n\n\n\n## Ejemplo de Error de truncamiento\n\n::: {.callout-warning title=\"Recordemos\" collapsible=\"false\"}\n\n$$R_n\\left( x \\right) = \\frac{f^{\\left( n+1 \\right)}\\left( \\xi \\right)}{\\left( n+1 \\right)!}\\left( x-c \\right)^{n+1}$$\n\n:::\n\n::: {.callout-note title=\"Error en forma de lagrange\" collapsible=\"false\"}\n\n$$R_4\\left(1.1\\right) = \\frac{24\\xi^{-5}}{5!}\\left(1.1 - 1\\right)^{5}$$\n\n:::\n\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef error_taylor_expansion(x):\n    return ((24*x**(-5))/120)*(0.1**5)\n\n```\n\n\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n:::{.center .small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n#| fig-align: center\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nv = np.arange(1,1.1,0.0001)\nerror = error_taylor_expansion(v)\nfig, ax = plt.subplots()\nax.plot(v,error)\nax.set_xlabel(\"Valor\")\nax.set_ylabel(\"Error de truncamiento\")\nplt.show()\n\n```\n\n:::\n\n\n## Ejemplo de Error de truncamiento\n\n::: {.callout-note title=\"Calcular ln(1.1), centrado en  c=1, y orden 4\" collapsible=\"false\"}\n\n:::{.small_font}\n\n  $$f\\left(1.1\\right)=ln\\left(1\\right)+\\frac{1}{1}\\left(1.1 - 1\\right)-\\frac{1}{2\\cdot 1^2}\\left(1.1-1\\right)^2+\\frac{2}{6\\cdot 1^3}\\left(1.1 - 1\\right)^3 - \\frac{6}{24\\cdot 1^4}\\left(1.1 - 1\\right)^4$$\n\n:::\n\n\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef taylor_expansion_ln(x):\n    return ((1/1)*(x-1))-((1/(2*(1**2)))*(x-1)**2)+ ((2/(6*(1**3)))*(x-1)**3)-((6/(24*(1**4)))*(x-1)**4)\n\n```\n\n:::\n\n:::{.small_font}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(taylor_expansion_ln(1.1))\n\n\n```\n\n:::\n\n\n## Error de redondeo\n\n\n\n::: {.callout-important title=\"Supongamos...\" collapsible=\"false\"}\n\n$$x=\\frac{5}{7}$$\n$$y = \\frac{1}{3}$$\n\n1. Calcular x+y utilizando aritmética de digitos finitos, utilizando 6 cifras significativas, considerando:\n  \n    - Método de truncamiento\n    - Método de redondeo\n\n2. Calcular el error para todos los casos anteriores\n:::\n\n## Error de redondeo{.scrollable}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(5.0/7.0)\n\n```\n\nUtilizando redondeo...\n\n$$x=0.714286\\times10^0$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(1.0/3.0)\n\n```\n\nUtilizando redondeo...\n\n$$x=0.333333\\times10^0$$\n\n:::\n\n:::\n\n$$x+y=0.104762\\times10^{1}$$\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint( \"Error absoluto:\", abs(((22.0/21.0) - (1.04762))) )\nprint( \"Error relativo:\", abs(((22.0/21.0) - (1.04762))/((22.0/21.0))) )\n\n```\n\n## Error de redondeo{.scrollable}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(5.0/7.0)\n\n```\n\nUtilizando truncamiento...\n\n$$x=0.714285\\times10^0$$\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint(1.0/3.0)\n\n```\n\nUtilizando truncamiento...\n\n$$x=0.333333\\times10^0$$\n\n:::\n\n:::\n\n$$x+y=0.104761\\times10^{1}$$\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\nprint( \"Error absoluto:\", abs(((22.0/21.0) - (1.04761))) )\nprint( \"Error relativo:\", abs(((22.0/21.0) - (1.04761))/((22.0/21.0))) )\n\n```\n\n<!-- TODO:algoritmos y convergencia-Seción 1.3 de Burden  -->\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 1\" collapsible=\"false\"}\n\nLa raiz de la función $f\\left(x\\right) = 3x-4$ es $x=\\frac{4}{3}$\n\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 2\" collapsible=\"false\"}\n\nLos ceros de la función $f\\left(x\\right) = x^2 -x -6$ son $x=3$ y $x=-2$\n\n:::\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 1\" collapsible=\"false\"}\n\nLa raiz de la función $f\\left(x\\right) = 3x-4$ es $x=\\frac{4}{3}$\n\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(0,2,0.01)\nf_x = 3*x-4\nfig, ax = plt.subplots()\nax.plot(x, f_x)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 1\" collapsible=\"false\"}\n\nLa raiz de la función $f\\left(x\\right) = 3x-4$ es $x=\\frac{4}{3}$\n\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(0,2,0.01)\nf_x = 3*x-4\nfig, ax = plt.subplots()\nax.plot(x, f_x)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.arange(-3,4, 0.01)\nf_t = (t**2)-(t)-6\n\nfig, ax = plt.subplots()\nax.plot(t, f_t)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 2\" collapsible=\"false\"}\n\nLos ceros de la función $f\\left(x\\right) = x^2 -x -6$ son $x=3$ y $x=-2$\n\n:::\n\n\n\n:::\n\n:::\n\n## Búsqueda de \\\"raíces\\\" de una función\n\n::: {.callout-note title=\"Definicón\" collapsible=\"false\"}\n\nLas raíces o ceros de una función $f$ son aquellos valores $c$ tal que: $f\\left(c\\right)=0$\n\n:::\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.arange(-3,4, 0.01)\nf_t = (t**2)-(t)-6\n\nfig, ax = plt.subplots()\nax.plot(t, f_t)\nplt.grid(True)\nplt.show()\n\n```\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.callout-warning title=\"Ejemplo 2\" collapsible=\"false\"}\n\nLos ceros de la función $f\\left(x\\right) = x^2 -x -6$ son $x=3$ y $x=-2$\n\n:::\n\n\n\n:::\n\n:::\n\n## Que pasa con funciones más complejas\n\nEn muchas ecuaciones en ciencias e ingeniería, en las cuales no es posible aplicar un procedimiento para despejar la incógnita.\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n- $f\\left(x\\right) = x - $cos\\left(x\\right)$\n\n- $f\\left(x\\right) = e^{-x} - sin\\left(x\\right)$\n:::\n\n:::{.column width=\"50%\"}\n\n- $f\\left(x\\right) = x - tan\\left(x\\right)$\n\n- $f\\left(x\\right) = e^{x} - x$\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n:::{.small_font}\n\nA menudo, el crecimiento de una población se puede modelar sobre periodos breves al asumir que aumenta de manera continua con el tiempo a una tasa proporcional al número actual en ese momento. Suponga que $N\\left(t\\right)$ denota el número en la población en el tiempo t y λ denota la tasa constante de natalidad. Entonces, dicha población satisface la ecuación diferencial:\n\n$$\\frac{d N\\left(t\\right)}{dt}=\\lambda N\\left(t\\right)$$\n\nCuya solución es $N\\left(t\\right)=N_0 e^{\\lambda t}$\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN_o = 1e6\nl_i = 0.5\n\nt = np.arange(0,10,0.01)\nN_t = N_o*np.exp(l_i*t)\n\nfig, ax = plt.subplots()\nax.plot(t, N_t)\nplt.show()\n```\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n:::{.small_font}\n\nA menudo, el crecimiento de una población se puede modelar sobre periodos breves al asumir que aumenta de manera continua con el tiempo a una tasa proporcional al número actual en ese momento. Suponga que $N\\left(t\\right)$ denota el número en la población en el tiempo t y λ denota la tasa constante de natalidad. Entonces, dicha población satisface la ecuación diferencial:\n\n$$\\frac{d N\\left(t\\right)}{dt}=\\lambda N\\left(t\\right)$$\n\nCuya solución es $N\\left(t\\right)=N_0 e^{\\lambda t}$\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.plot(t, N_t)\nplt.show()\n```\n\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Suponga que....\" collapsible=\"false\"}\n\nSuponga que, en un inicio, cierta población contiene $N\\left(0\\right)=1000000$ individuos, que $\\upsilon=435000$ individuos inmigran a la comunidad durante el primer año y que existen N\\left(1\\right)=1564000 al finalizar el año. SI deseamos determinar el la tasa de natalidad $\\lambda$ se requiere encontrar las raíces de\n\n:::{.small_font}\n\n$$1564000 = 1000000e^{\\lambda} + \\frac{435000}{\\lambda}\\left(e^{\\lambda}-1\\right)$$\n\n:::\n\n\n\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: false\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlam = np.arange(0,0.2,0.0001)\n\ndef f(l):\n    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000\n\nfig, ax = plt.subplots()\nax.plot(lam, f(lam))\nax.grid(True)\nplt.show()\n```\n\n:::\n\n:::\n\n\n## Soluciones de ecuaciones de una variable\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n::: {.callout-note title=\"Suponga que....\" collapsible=\"false\"}\n\nSuponga que, en un inicio, cierta población contiene $N\\left(0\\right)=1000000$ individuos, que $\\upsilon=435000$ individuos inmigran a la comunidad durante el primer año y que existen N\\left(1\\right)=1564000 al finalizar el año. SI deseamos determinar el la tasa de natalidad $\\lambda$ se requiere encontrar las raíces de\n\n:::{.small_font}\n\n$$1564000 = 1000000e^{\\lambda} + \\frac{435000}{\\lambda}\\left(e^{\\lambda}-1\\right)$$\n\n:::\n\n:::\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlam = np.arange(0,0.2,0.0001)\n\ndef f(l):\n    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000\n\nfig, ax = plt.subplots()\nax.plot(lam, f(lam))\nax.grid(True)\nplt.show()\n```\n\n:::\n\n:::\n\n\n\n## Método de la bisección{.scrollable}\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlam = np.arange(0.05,0.2,0.0001)\n\ndef f(l):\n    return 1000000*np.exp(l) + ((435000)/(l)*((np.exp(l))-1)) - 1564000\n\nvalor = np.array([0.05, 0.2])\n\nfig, ax = plt.subplots()\nax.plot(lam, f(lam))\nax.stem(valor, f(valor), linefmt=':')\nax.grid(True)\nplt.show()\n\n```\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n![](./images/NumericalAnalysis/met_biseccion.jpg)\n\n:::\n\n:::\n\n## Método de la bisección\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef met_bisectriz(a,b,tol,g,No):\n    i = 0\n    FA = g(a)\n    while i <= No:\n        p = a+ ((b-a)/2)\n\n        FP = g(p)\n        if (FP==0) or (((b-a)/2)<tol):\n            print(\"Lo logré, raíz en:\", p, FP)\n            return p,i\n            break\n        i=i+1\n        if FA*FP > 0:\n            a=p\n            FA=FP\n        else:\n            b=p\n    print(\"Termine: \", i)\n\n```\n\n## Método de Regula-Falsi\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\n\ndef g(x):\n    return np.sin(x+0.5)\n\nlam = np.arange(-np.pi/2,np.pi/2, 0.001)\n\nfig, ax = plt.subplots()\na = -1.2\nb = 0.8\nax.plot(lam, g(lam))\nax.axhline(y=0, color=\"red\")\nax.stem([a, b], [g(a), g(b)], linefmt=':')\nax.axline((a, g(a)), slope=(g(b)-g(a))/(b-a), color=\"black\", linestyle='--')\nax.grid(True)\nplt.show()\n\n```\n\n\n## Método de Regula-Falsi\n\n```{python}\n#| echo: true\n#| eval: true\n#| output: true\n\ndef met_regula_falsi(a,b,tol,g,No):\n    i = 0\n    FA = g(a)\n    FB = g(b)\n    while i <= No:\n        p = a - ((FA*(b-a))/(FB-FA))\n        FP = g(p)\n        if (FP==0) or (((b-a)/2)<tol):\n            #print(\"Lo logré, raíz en:\", p, FP)\n            return p,i\n            break\n        i=i+1\n        if FA*FP > 0:\n            a=p\n            FA=FP\n        else:\n            b=p\n            FB=FP\n    print(\"Termine: \", i)  \n\n```\n\n\n\n\n## Método de Newton-Raphson\n\n::: columns\n\n:::{.column width=\"50%\"}\n\n```{python}\n#| echo: false\n#| eval: true\n#| output: true\ndef g(x):\n    return np.sin(x+0.5)\n\ndef der_g(x):\n    return np.cos(x+0.5)\n\nlam = np.arange(-np.pi/2,np.pi/2, 0.001)\np0 = 0.6\np1 = p0 - ((g(p0))/(der_g(p0)))\nfig, ax = plt.subplots()\nax.plot(lam, g(lam))\nax.axhline(y=0, color=\"red\")\nax.stem(p0, g(p0), linefmt=':')\nax.axline((p0, g(p0)), slope=der_g(p0), color=\"black\", linestyle='--')\nax.stem(p1, g(p1), linefmt=':')\nax.axline((p1, g(p1)), slope=der_g(p1), color=\"green\", linestyle='--')\nax.grid(True)\nplt.show()\n\n```\n\n\n\n:::\n\n:::{.column width=\"50%\"}\n\n![](./images/NumericalAnalysis/newton-raphson.jpg)\n\n:::\n\n:::\n\n\n\n## Taller\n\n::: {.callout-note title=\"Pregunta 1/2\" collapsible=\"false\"}\n\nDada la función $f\\left(x\\right) = 8 sin\\left(x\\right) e^{-x} - 1$ responda las siguientes cuestiones:\n\n1. Si se sabe que $x \\in \\left[0,3\\right]$, encuentre una raíz de la función. ¿Es utilizable el método de la bisección en el cálculo de la raíz?\n\n2. Aplique Newton-Raphson para dos posibles valores iniciales: -5, 10. Cual es el resultado de la operación. Explique su resultado.\n\n:::\n\n## Taller\n\n::: {.callout-note title=\"Pregunta 2/2\" collapsible=\"false\"}\n\nLa velocidad de un para caídista esta dada por la siguiente función:\n\n$$v=\\frac{gm}{c}\\left(1 - e^{-\\frac{c}{m}t}\\right)$$\n\nSea la gravedad $g=9.8$, el coeficiente de rozamiento $c=14Kg/s$, responda:\n\n1. Cuál es el peso del paracaidista si se sabe que a los 7sg la velocidad de este era de $35m/s$ ?\n\n2. Utilizando una [calculadora de gravedad](https://www.sensorsone.com/local-gravity-calculator/), determine la gravedad real, si el experimento se hace en la ciudad de Popayán, vuelva a determinar la masa del paracaidista. Explique la discrepancia.\n\n:::\n\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","self-contained":true,"css":["styles.css"],"output-file":"NumericalAnalysis.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"En esta página","related-formats-title":"Otros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fuente","section-title-abstract":"Resumen","section-title-appendices":"Apéndices","section-title-footnotes":"Notas","section-title-references":"Referencias","section-title-reuse":"Reutilización","section-title-copyright":"Derechos de autor","section-title-citation":"Cómo citar","appendix-attribution-cite-as":"Por favor, cita este trabajo como:","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Autor/a","title-block-author-plural":"Autores/as","title-block-affiliation-single":"Afiliación","title-block-affiliation-plural":"Afiliaciones","title-block-published":"Fecha de publicación","title-block-modified":"Fecha de modificación","callout-tip-title":"Tip","callout-note-title":"Nota","callout-warning-title":"Advertencia","callout-important-title":"Importante","callout-caution-title":"Precaución","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar todo el código","code-tools-hide-all-code":"Ocultar todo el código","code-tools-view-source":"Ver el código fuente","code-tools-source-code":"Ejecutar el código","code-line":"Línea","code-lines":"Líneas","copy-button-tooltip":"Copiar al portapapeles","copy-button-tooltip-success":"Copiado","repo-action-links-edit":"Editar esta página","repo-action-links-source":"Ver el código","repo-action-links-issue":"Informar de un problema","back-to-top":"Volver arriba","search-no-results-text":"Sin resultados","search-matching-documents-text":"documentos encontrados","search-copy-link-title":"Copiar el enlace en la búsqueda","search-hide-matches-text":"Ocultar resultados adicionales","search-more-match-text":"resultado adicional en este documento","search-more-matches-text":"resultados adicionales en este documento","search-clear-button-title":"Borrar","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search-label":"Buscar","toggle-section":"Alternar sección","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo oscuro","toggle-reader-mode":"Alternar modo lector","toggle-navigation":"Navegación de palanca","crossref-fig-title":"Figura","crossref-tbl-title":"Tabla","crossref-lst-title":"Listado","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolario","crossref-prp-title":"Proposición","crossref-cnj-title":"Conjetura","crossref-def-title":"Definición","crossref-exm-title":"Ejemplo","crossref-exr-title":"Ejercicio","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apéndice","crossref-sec-prefix":"Sección","crossref-eq-prefix":"Ecuación","crossref-lof-title":"Listado de Figuras","crossref-lot-title":"Listado de Tablas","crossref-lol-title":"Listado de Listados","environment-proof-title":"Prueba","environment-remark-title":"Observación","environment-solution-title":"Solución","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Por defecto","listing-page-order-by-date-asc":"Menos reciente","listing-page-order-by-date-desc":"Más reciente","listing-page-order-by-number-desc":"De mayor a menor","listing-page-order-by-number-asc":"De menor a mayor","listing-page-field-date":"Fecha","listing-page-field-title":"Título","listing-page-field-description":"Descripción","listing-page-field-author":"Autor/a","listing-page-field-filename":"Nombre de archivo","listing-page-field-filemodified":"Fecha de modificación","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tiempo de lectura","listing-page-field-categories":"Categorías","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Todas","listing-page-no-matches":"No hay resultados"},"metadata":{"lang":"es","fig-responsive":false,"quarto-version":"1.3.433","auto-stretch":true,"title":"Análisis Numérico","description":"Sitio de la asignatura análisis numérico en la UniAutonoma del Cauca","subtitle":"Ingeniería de software y computación","author":"Ph.D. Pablo Eduardo Caicedo Rodríguez","date":"2023-08-01","resources":["demo.pdf"],"code-copy":false,"theme":["white","custom.scss"],"slideNumber":true,"previewLinks":"auto","logo":"images/medes.png","footer":"<https://pacaicedo.github.io>","transition":"fade"}}},"projectFormats":["html"]}